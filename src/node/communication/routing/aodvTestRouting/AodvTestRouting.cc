/*
 * @Author: Mathieu MICHEL (http://w3.umons.ac.be/staff/Michel.Mathieu/)
 *
 * Copyright (C) 2013  Mathieu MICHEL
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */


#include "AodvTestRouting.h"
#include <csimulation.h>
#include <CastaliaModule.h>
#include <ResourceManager.h>
#include "ApplicationPacket_m.h"   // added by diana 
#include <ctime>
#include <ratio>
#include <chrono>
#include <typeinfo>
#include <string>
#include <chrono>
#include <thread>
#include <iostream>
#include <time.h>


using namespace std;
Define_Module(AodvTestRouting);

void AodvTestRouting::startup()
{
	activeRouteTimeout = (double)par("activeRouteTimeout") / 100.0;
	allowedHelloLoss = par("allowedHelloLoss");
	helloInterval = (double)par("helloInterval") / 1000.0;
	localAddTTL = par("localAddTTL");
	netDiameter = par("netDiameter");
	frameSize = par("frameSize");
	//int activeRouteTimeoutTemp = par("activeRouteTimeout");
	//activeRouteTimeout = (activeRouteTimeoutTemp + (frameSize * netDiameter)/2)/1000.0;
	nodeTraversalTime = (double)par("nodeTraversalTime") / 1000.0;
	netTraversalTime = 2*nodeTraversalTime*netDiameter;
	pathDiscoveryTime = 2*netTraversalTime;
	rerrRatelimit = par("rerrRatelimit");
	rreqRetries = par("rreqRetries");
	rreqRatelimit = par("rreqRatelimit");
	timeoutBuffer = par("timeoutBuffer");
	ttlStart = par("ttlStart");
	ttlIncrement = par("ttlIncrement");
	ttlThreshould = par("ttlThreshould");
	shortestDelay = par("shortestDelay");
	atmode = par("atmode");
	callSugar = 3;//added by Raj on 5/2

	rreqExpTime = netTraversalTime;
	rreqExpTimeB = pathDiscoveryTime;

    trace() << "AODV : T : Testing purposes  ";//added simTime() by raj on 5/11/2018


	//test to choose the adaptation of aodv timers (depending of smac parameters)
	if(atmode !=0)
	{
		int activeRouteTimeoutTemp = par("activeRouteTimeout");
		activeRouteTimeout = activeRouteTimeoutTemp + (2 * frameSize * netDiameter)/1000.0;
		if(atmode == 2)
		{
			rreqExpTime = (2 * nodeTraversalTime * netDiameter) + (2 * frameSize * netDiameter)/1000.0;
			rreqExpTimeB = pathDiscoveryTime + (2 * frameSize * netDiameter)/1000.0;
		}
	}

	currSN = 1; //the current sequence number of this node (start from 1, 0 represents invalid value)
	rreqID = 0; //start from 1, but 0 because incremented before sending
	rtable = new AodvRoutingTable();//the routing table
	rreqTable = new AodvRREQTable();//the rreq which have been generated by this node

    declareOutput("Pkt sent");
    declareOutput("Pkt received");
    declareOutput("Timers expired");

    respTimeAverage = 0; //the average time between the generation of RREQ and the reception of RREP
    respTimeMax = numeric_limits<double>::min( ); //the minimum time between the generation of RREQ and the reception of RREP
    respTimeMin = numeric_limits<double>::max( ); //the maximum time between the generation of RREQ and the reception of RREP
    respTimeTotal = 0;
    rrepRxCount=0;

    latencyMax = hasPar("latencyHistogramMax") ? par("latencyHistogramMax") : 0;
    latencyMin = hasPar("latencyHistogramMin") ? par("latencyHistogramMin") : 0;
    latencyBuckets = hasPar("latencyHistogramBuckets") ? par("latencyHistogramBuckets") : 0;
    if (latencyMax > 0 && latencyBuckets > 0)
        declareHistogram("RREQ response time, in s", latencyMin, latencyMax, latencyBuckets);

    resMgrModule = check_and_cast <ResourceManager*>(getParentModule()->getParentModule()->getSubmodule("ResourceManager"));  // Diana 2/5/19  *****
    trace()<<" Node' spent energy is "<<resMgrModule->getSpentEnergy() ;   
}

void AodvTestRouting::sendSugar()//creating fucntion to send sugar(RReQ) packets by Raj.
{
    currSN++;

    trace() << "starting implematation ";
    std::string s = std::to_string(BROADCAST_MAC_ADDRESS);
    char const *dst = s.c_str(); 

    //std::string path=getFullPath();//to check for node number. added by Raj on 5/2/2019

    sendPktRREQ(0,(callSugar-3) ,string(SELF_NETWORK_ADDRESS) ,dst, currSN,0,SimTime(), 0);		

}

void AodvTestRouting::finish()
{
    VirtualRouting::finish();
    PacketRREQ* rreqpkt;
    PacketRERR* rerrpkt;
    // clear the buffer
    while (!rreqBuffer.empty()) {
        rreqpkt = rreqBuffer.front();
        rreqBuffer.pop();
        cancelAndDelete(rreqpkt);
    }
    while (!rerrBuffer.empty()) {
        rerrpkt = rerrBuffer.front();
        rerrBuffer.pop();
        cancelAndDelete(rerrpkt);
    }

    trace()<<" Total consumed energy is:"<<resMgrModule->getSpentEnergy();
}

void AodvTestRouting::timerFiredCallback(int index)
{
    switch(index)
    {
        case AODV_RREQ_BROADCAST_DROP_TIMER:
        {
            trace() << "AODV : T : AODV_RREQ_BROADCAST_DROP_TIMER expired";
            rreqBroadTable.pop();
            collectOutput("Timers expired","rreq broadcasted");
            while(!rreqBroadTable.empty()!=0 && rreqBroadTable.top().lifetime - simTime().dbl()<=0)
            {
                rreqBroadTable.pop();
                collectOutput("Timers expired","rreq broadcasted");
            }
            if(!rreqBroadTable.empty())
                    setTimer(AODV_RREQ_BROADCAST_DROP_TIMER, rreqBroadTable.top().lifetime - simTime().dbl());

        }
            break;

        case AODV_RREQ_EXPIRATION_TIMER:
        {
            if(rreqTable->getTableSize()!=0)
            {
                double nextExpiredRREQTime = rreqTable->getNextExpiredRREQ()->lifetime;
                string nextExpiredRREQ = rreqTable->getNextExpiredRREQ()->dest;
                int nextExpiredRREQID = rreqTable->getNextExpiredRREQ()->rreqID;
                rreqTable->removeRREQ(nextExpiredRREQ);
                collectOutput("Timers expired","rreq");
                trace() << "AODV : T : RREQ (generated expired) with id : "<<nextExpiredRREQID;
                if(rreqTable->getTableSize()!=0)
                    setTimer(AODV_RREQ_EXPIRATION_TIMER, rreqTable->getNextExpiredRREQ()->lifetime - simTime().dbl());
                if(rreqRetryCount[nextExpiredRREQ] < rreqRetries)//send another rreq if rreqRetries number not reached
                {
                    rreqID++;
                    trace() << "AODV : RREQ : rreq resent for destination : "<<nextExpiredRREQ;
                    sendPktRREQ(0, rreqID, SELF_NETWORK_ADDRESS, nextExpiredRREQ,currSN, rtable->getDstSN(nextExpiredRREQ,"Ordinary",1),simTime(), 0);//Changed by Raj. Unsure :(
                }
                else
                {
                    trace() << "AODV : RREQ : rreq "<< nextExpiredRREQID<< " canceled for destination : "<<nextExpiredRREQ;
                    rreqRetryCount[nextExpiredRREQ] = 0;
                    processBufferedDATA(nextExpiredRREQ.c_str(),true);
                    //TODO: notify the application layer that the link is not available
                }
            }
        }
            break;

        case AODV_ROUTING_TABLE_ENTRY_EXPIRATION_TIMER:
        {
            trace() << "AODV : T : AODV_ROUTING_TABLE_ENTRY_EXPIRATION_TIMER expired";
            const RouteTimer* r = rtable->getNextExpiredRoute();
            if(r && !r->canceled)
            {
                //routeUpdateCount[r->destination]--;
                //if(routeUpdateCount[r->destination]==0)
                rtable->searchByDest(r->destination,r->dtype,r->priority)->flag=INVALID;//changed by raj to r->type and r->prior on 23/02/2019
                trace() << "AODV : R : expired route to " << string(r->destination);
                //rtable->removeRoute(r->dstIP);
                collectOutput("Timers expired","route");
            }
            rtable->clearTimerExpired();

            while(rtable->getTimersSize()!=0 && rtable->getNextExpiredRoute()->lifetime - simTime().dbl()<=0)
            {
                    r=rtable->getNextExpiredRoute();//changed by raj  on 23/02/2019
                  string s = r->destination;//changed by raj on 23/02/2019
                  if(!rtable->getNextExpiredRoute()->canceled)
                  {
                        //routeUpdateCount[s]--;

                        //if (routeUpdateCount[s]==0 && rtable->getFlag(s)==VALID)
                        rtable->searchByDest(s,r->dtype,r->priority)->flag=INVALID;//changed by raj to r->type and r->prior on 23/02/2019
                  }
                  rtable->clearTimerExpired();
                  trace() << "AODV : R : expired route to " << s;
                  collectOutput("Timers expired","route");
            }
            if(rtable->getTimersSize()!=0)
            {
              setTimer(AODV_ROUTING_TABLE_ENTRY_EXPIRATION_TIMER, rtable->getNextExpiredRoute()->lifetime - simTime().dbl());
            }
        }
            break;

        case AODV_RREQ_RATE_LIMIT_TIMER:
        {
            trace() << "AODV : T : AODV_RREQ_RATE_LIMIT_TIMER expired";
            if(!rreqBuffer.empty())
            {
                processBufferedRREQ();
            }
    	   // setTimer(AODV_RREQ_RATE_LIMIT_TIMER, (double)1/rreqRatelimit);

        }
            break;

        case AODV_HELLO_MESSAGE_REFRESH_TIMER:
        {
            trace() << "AODV : T : AODV_HELLO_MESSAGE_REFRESH_TIMER expired";
            sendPktHELLO();
        }
            break;

        /*case AODV_HELLO_MESSAGE_EXPIRE_TIMER:
        {
            trace() << "AODV : T : AODV_HELLO_MESSAGE_EXPIRE_TIMER expired";
            string neib = helloTimer.top().destination;

            //this counter is used because an old hello message timer is not remove when we received a new one.
            //So it could be a problem when an old hello message timer expires but that a new one is already received
            hmUpdateCount[neib]--;
            if (hmUpdateCount[neib]==0)
            {
                list<string>* affectedDest = new list<string>();
                list<string>* affectedPrecursor = new list<string>();
                rtable->setLinkFailure(neib.c_str(), affectedDest, affectedPrecursor);
                resetLifetimeRoute(neib);
                sendPktRERR(affectedDest, affectedPrecursor);
            }
            helloTimer.pop();
            while(!helloTimer.empty() && helloTimer.top().lifetime - simTime().dbl()<=0)
            {
                string dest3 = helloTimer.top().destination;
                hmUpdateCount[dest3]--;
                if (hmUpdateCount[dest3]==0)
                {
                    list<string>* affectedDest = new list<string>();
                    list<string>* affectedPrecursor = new list<string>();
                    rtable->setLinkFailure(dest3.c_str(), affectedDest, affectedPrecursor);
                    resetLifetimeRoute(dest3);
                    sendPktRERR(affectedDest, affectedPrecursor);
                }
                helloTimer.pop();
            }
            if(!helloTimer.empty())
                setTimer(AODV_HELLO_MESSAGE_EXPIRE_TIMER, helloTimer.top().lifetime - simTime().dbl());
        }
            break;*/

        case AODV_RERR_RATE_LIMIT_TIMER:
        {
            trace() << "AODV : T : AODV_RERR_RATE_LIMIT_TIMER expired";
            if(!rerrBuffer.empty())
            {
                collectOutput("Pkt sent","RERR pkt");
                toMacLayer(rerrBuffer.front(), resolveNetworkAddress(rerrBuffer.front()->getDestination()));
                rerrBuffer.pop();
                setTimer(AODV_RREQ_RATE_LIMIT_TIMER, (double)1/rerrRatelimit);
            }
        }
            break;
        case AODV_RREP_ACK_WAIT_TIMER:
        {
           trace() << "AODV : T : AODV_RREP_ACK_WAIT_TIMER expired";
            if(!rrepAcked[rrepAck.top().destination])
                setBlacklistTimer(rrepAck.top().destination.c_str());
            rrepAck.pop();
            if(!rrepAck.empty())
            {
                setTimer(AODV_RREP_ACK_WAIT_TIMER, rrepAck.top().lifetime - simTime().dbl());
            }
        }
            break;

        case AODV_RREQ_BLACKLIST_REMOVE_TIMER:
            {
                trace() << "AODV : T : AODV_RREQ_BLACKLIST_REMOVE_TIMERR expired";
                string node = string(rreqBlacklist.top().destination);
                rreqBlacklist.pop();
                if(!rreqBlacklist.empty())
                {
                	if(rreqBlacklist.top().lifetime<simTime().dbl())
                	{
                		trace()<<"debug - destination"<<node;
                		setTimer(AODV_RREQ_BLACKLIST_REMOVE_TIMER, 1);
                	}
                	else
                		setTimer(AODV_RREQ_BLACKLIST_REMOVE_TIMER, rreqBlacklist.top().lifetime - simTime().dbl());
                }
            }
            break;

        default:
            return;

    }
    return;
}

void AodvTestRouting::fromMacLayer(cPacket * pkt, int srcMacAddress, double rssi, double lqi)
{
	AODVPacketTypes packetType;
	//get the packet type (as ddefined in packet.msg files)
	PacketRREQ *rreq = dynamic_cast <PacketRREQ*>(pkt);
	PacketRREP *rrep = dynamic_cast <PacketRREP*>(pkt);
	PacketRERR *rerr = dynamic_cast <PacketRERR*>(pkt);
	PacketDATA *data = dynamic_cast <PacketDATA*>(pkt);
	PacketHELLO *hello = dynamic_cast <PacketHELLO*>(pkt);
	PacketRREPack *rrepA = dynamic_cast <PacketRREPack*>(pkt);
    

	if (data)
		packetType = AODV_DATA;
	else if (hello)
		packetType = AODV_HELLO;
	else if(rreq)
		packetType = AODV_RREQ;
	else if(rrep)
		packetType = AODV_RREP;
	else if(rrepA)
		packetType = AODV_RREP_ACK;
	else if(rerr)
		packetType = AODV_RERR;
	else
		packetType = AODV_UNKNOWN;


	switch(packetType)
	{
			case AODV_DATA:
                int val;
                //trace()<<" pkt type and priority before converting into data packet type is:"<<pkt->dtype<<":"<<pkt->priority<<":"; 
                trace() << "AODV : A1 : DATA received - from: " << string(data->getSource())
                             << " destination: " << string(data->getDestinationAodv())<<" PktID :"<<data->getSequenceNumber()<<" Typ:"<<data->dtype<<" pri:"<< data->priority<<" data->priorityTypeVal:"<<data->priorityTypeVal;
               
               // IMPORTANT NEED tO look into it, since type and priority are getting invalid after 2 hops.. 
                // added by diana since, packets' priority and type are changed...
               // trace()<<"testing about execution control data->dtype.compare(" ") is :"<<data->dtype.compare(" ")<<":"  ; 
                if ( ( data->priority != 1 || data->priority != 2 ) ||  data->dtype.compare(" ")  )  // then type is reassigned here. 
                {  // ***************** IMPO: whole bloack needs to be changed later
                   
                    long v= data->getSequenceNumber() ;
                    int type = (v % 4);//added by raj on 23/2/19
                    
                    switch(type){
                        case 0:
                        {   //trace()<<"@fromApplicationL: testing_Ordinary";
                            data->dtype = "Ordinary";
                            break;
                        }
                        case 1: 
                        {   //trace()<<"@fromApplicationL: testing_Reliable";
                            data->dtype = "Reliable";
                            break;
                        }                                           //added  by raj to assign random values
                        case 2: 
                        {   //trace()<<"@fromApplicationL: testing_Delay";
                            data->dtype = "Delay";
                            break;
                        }
                        case 3: 
                        {  // trace()<<"@fromApplicationL: testing_Critical";
                            data->dtype = "Critical";
                            break;
                        }

                    }
                    trace()<<"@fromAppli: dta type reassign type, "<<data->dtype;
                    data->priority=1;   // need to be random based on selected SECONDARY or PRIMARY paths. 
                    // ********************************

                    /*trace()<<"inside if data->dtype & data->priority:1"<<data->dtype<<":"<<data->priority<<":";
                    val = data->priorityTypeVal[0] - '0' ; 
                    trace()<<"inside if data->dtype & data->priority:2 val "<<val;
                    data->dtype = (data->priorityTypeVal).substr(2);
                    trace()<<"inside if data->dtype & data->priority:3 "<<data->dtype<<":"<<data->priority<<":";
                    data->priority = val ; */
                    
                 } 

			   // trace() << "AODV : A1 : DATA received - from: " << string(data->getSource())
			               // <<" PktID :"<<data->getSequenceNumber()<<" Typ:"<<data->dtype<<" pri:"<< data->priority<<" val:"<<val;
				receivePktDATA(data);
				break;

			case AODV_HELLO:
                //trace() << "AODV : A1 : HELLO received - from: " << string(hello->getSource());
			    //collectOutput("Pkt received","HELLO pkt");
				receivePktHELLO(hello);
				break;

			case AODV_RREQ:
			    /*trace() << "AODV : A1 : RREQ received - origin: " << string(rreq->getSrcIP())
			                                            << " id: " << rreq->getRreqID()
			                                            << " destination: " << string(rreq->getDstIP())
			                                            << " from: " << string(rreq->getSource());*/
			    collectOutput("Pkt received","RREQ pkt");
				receivePktRREQ(rreq, srcMacAddress, rssi, lqi);
				break;

			case AODV_RREP:
                /*trace() << "AODV : A1 : RREP received - origin (AODV dst): " << string(rrep->getDstIP())
                                                        << " destination (AODv src): " << string(rrep->getOriginIP())
                                                        << " from: " << string(rrep->getSource());*/
				receivePktRREP(rrep, srcMacAddress, rssi, lqi);
				break;

			case AODV_RREP_ACK:
			    trace() << "AODV : RREPack : received - from: " << string(rrepA->getSource());
			    if(string(rrepA->getDestination()).compare(SELF_NETWORK_ADDRESS)==0)
			    {
			        collectOutput("Pkt received","RREPack pkt");
			        rrepAcked[string(rrepA->getSource())] = true;
			    }
				break;

			case AODV_RERR:
			    //trace() << "AODV : A1 : RERR received - from: " << string(rerr->getSource());
				receivePktRERR(rerr, srcMacAddress, rssi, lqi);
				break;

			default:
				return;
	}
	return;

}

//application layer can only send data packets
void AodvTestRouting::fromApplicationLayer(cPacket * pkt, const char *destination)
{
    node_Pkt_Count++;    
    Recvd_Pkt_Count++;  // Receiving from it's application layer 
	PacketDATA *data = new PacketDATA("AODV routing data packet", NETWORK_LAYER_PACKET);
	data->setSource(SELF_NETWORK_ADDRESS);
	data->setDestinationAodv(destination);
	data->setDestination(destination);
    SimTime arrivalTime1 = simTime() ;  //Returns current simulation time
// encapsulatePacket(data, pkt);


   // processBufferedDATA(destination,false); // Called by diana for testing 
  //  trace()<<" pkt type is "<<pkt->getType();
// 	trace() << "AODV :fromApp: Recvd_Pkt_Count() " << string(destination)<< " Pkt No: "<<pkt << " TXBufferal: "<< Recvd_Pkt_Count;
	if(string(destination).compare(BROADCAST_NETWORK_ADDRESS)==0)
	{
	        return;
			//do not route broadcast package
			//toMacLayer(data, BROADCAST_MAC_ADDRESS);
	}

    string pktType;

    std::string path=getFullPath();
   // srand((int)path[8]);
    // srand(0);
    long v= node_Pkt_Count ;
    int type = (v % 4);//added by raj on 23/2/19
  //  trace()<<"@fromAppli: rand is & type "<<v<<"  "<<type;
    switch(type){
        case 0:
        {   //trace()<<"@fromApplicationL: testing_Ordinary";
            pktType = "Ordinary";
            break;
        }
        case 1: 
        {   //trace()<<"@fromApplicationL: testing_Reliable";
            pktType = "Reliable";
            break;
        }                                           //added  by raj to assign random values
        case 2: 
        {   //trace()<<"@fromApplicationL: testing_Delay";
            pktType = "Delay";
            break;
        }
        case 3: 
        {  // trace()<<"@fromApplicationL: testing_Critical";
            pktType = "Critical";
            break;
        }

    }

    data->dtype=pktType;
    data->priority=1;   // NEED to CHANGE this priority to rand value this is for PRIMARY and SECONDARY paths. IMPORTANT
    int priority = data->priority;//raj on 15/3/19

   
    string s = to_string(data->priority); 
     char char_array[15], char_array1[20];
    strcpy(char_array, s.c_str());
    data->priorityTypeVal=strcat(char_array, ":"); 

    strcpy(char_array, (data->dtype).c_str());
    strcpy(char_array1, (data->priorityTypeVal).c_str());

    data->priorityTypeVal=strcat(char_array1 , char_array ); 

 //  trace()<<" s & char_array & data->priorityTypeVal :"<<s<<":"<<char_array<<":"<<data->priorityTypeVal<<":"<<"final:"<<data->priorityTypeVal; 

   /* char* val2 = new char[data->dtype.length() + 1]; 
    data->priorityTypeVal=strcat(val1, ":"); // added by diana to handle the dropping of the packets.
    char* val3 = new char[(data->priorityTypeVal).length() + 1 ] ; 
    data->priorityTypeVal=strcat(val3 , val2 ); 
 
    trace()<<"data->priorityTypeVal :"<<data->priorityTypeVal<<"data->priority:"<<data->priority<<";" ;   */

    // Added by diana for overwriting the priority , dtype values of the packet , this is used in from MACLayer code... 
  // int val= stoi(SELF_NETWORK_ADDRESS) ; 
   // pktVal[val].nodeId = val ;
   // pktVal[val].dtype = data->dtype ;
   // pktVal[val].priority = data->priority ;
   // pktVal[val].pktId = data->getSequenceNumber() ;  

  // trace()<<"BEF @ng::fromAppli data->priority & data->dtype"<<data->priority<<":"<<data->dtype<<": Pkt No: "<<data->getSequenceNumber()<<"Recvd_Pkt_Count:"<<Recvd_Pkt_Count ;

    encapsulatePacket(data, pkt);  // after encapsulating packet gets pkt id... 

    trace()<<" AFT @ng::fromAppli data->priority & data->dtype"<<data->priority<<":"<<data->dtype<<": Pkt No: "<<data->getSequenceNumber()<<"node_Pkt_Count:"<<node_Pkt_Count;

    // Added by diana on 21/5/2019
    // Keeps track of number of critical packets.
    if (data->dtype.compare("Critical")==0)
        Recvd_Critical_Pkt_Count++;


    // trace()<<"@fromApplicationL: data->dtype: "<< data->dtype<<" Recvd_Critical_Pkt_Count:"<<Recvd_Critical_Pkt_Count;   
     computeLoad();  // function defined by diana 
        
	//a valid route exist
	if(rtable->isRouteValid(string(destination),pktType,priority))//chaned by Raj on 23/02/2019
	{          
            if( (arrivalTime1 - Prev_Time_Interval_for_Dropping ) > 5 )   // Added by diana , for dropping the packets, once in each 5secs this get executed to drop the packets... (Dropping module works once in a 5secs. Drop ratio computation work once in a 3secs i.e whenever RREQ is called. )
                dropping_Flag = true; 

           // trace()<<"@fromAp arrivalTime1 & Prev_Time_Interval_for_Dr "<<arrivalTime1 <<" "<< Prev_Time_Interval_for_Dropping;
          // trace()<<"@fromApplicati data->dtype & dropping_Flag "<<data->dtype<<" "<<dropping_Flag ; 
            if (data->dtype.compare("Critical")!=0 && dropping_Flag )  //  if block is added by diana, to handle packet drops. 
            {   no_of_pkts_Dropped++;    // Means packet is dropped, so toMacLayer() is not called
                trace()<<"no_of_pkts_Dropped & no_of_Pkts_to_Drop "<< no_of_pkts_Dropped <<"  "<< no_of_Pkts_to_Drop <<" Pkt No: "<<data->getSequenceNumber();
                if (no_of_pkts_Dropped >= no_of_Pkts_to_Drop)
                {
                    dropping_Flag = false;
                    Prev_Time_Interval_for_Dropping = arrivalTime1;
                    no_of_pkts_Dropped = 0; // reinitailised for next dropping iteration
                }
                return; // if return is commented then BM module is not applied. 
            }               

			updateLifetimeRoute(string(destination), activeRouteTimeout,pktType,priority);//added 2 argumnets by raj on 23/02/19
			trace() << "AODV : B1 : DATA sent (route valid) - src-destination " << SELF_NETWORK_ADDRESS<< string(destination)
			                                                <<" via " <<rtable->getNextHop(destination,pktType,priority)<<" hop-count:"<<rtable->getHopCount(destination,pktType,priority)<< " Pkt No: "<<data->getSequenceNumber();//added 2 argumnets by raj on 23/02/19
			data->setDestination((rtable->getNextHop(destination,pktType,priority)).c_str());//added 2 argumnets by Raj 23/02/19
			collectOutput("Pkt sent","DATA pkt (S)");
			toMacLayer(data, resolveNetworkAddress((rtable->getNextHop(destination,pktType,priority)).c_str()));//added 2 argumnets by Raj 23/02/19
			return;
	}

	//if a rreq is not processed
	else if(!(AodvTestRouting::checkRREQProcessed(string(destination))))
	{    
			trace()<<" Inside fromAllpicatioLayer(): if a rreq is not processed ";
            currSN++;
			rreqID++;
			sendPktRREQ(0, rreqID, string(SELF_NETWORK_ADDRESS), string(destination), currSN, rtable->getDstSN(destination,pktType,priority),simTime(), 0);//added 2 argumnets by Raj 23/02/19
			//buffer the packet

	}

	//no valid route and no discovery process
	else
		trace() << "AODV : B1 : RREQ already processed - for destination " << string(destination);
    trace() << "AODV : B2 : DATA buffered - destination " << string(destination);
    bufferPacket(data);
}


void AodvTestRouting::receivePktDATA(PacketDATA *pkt)
{
    Recvd_Pkt_Count++;    // Receiving from other nodes to forward the data 
    // Keeps track of number of critical packets.
    if (pkt->dtype.compare("Critical")==0)
        Recvd_Critical_Pkt_Count++; 

         
   // trace()<<"@ RecvDataPkt, Recvd_Pkt_Count():& pkt->dtype & prioiryt :" << Recvd_Pkt_Count << ":"<<pkt->dtype<<":"<<pkt->priority<<":Pkt_SEQ_No: "<< pkt->getSequenceNumber()<< ": Src is :"<< string(pkt->getSource()) ; 
	string finalDst = string(pkt->getDestinationAodv());
  //  processBufferedDATA(finalDst,false);     
  //  trace() << "forwarded to destination Src-Dest-NextHop: " <<string(pkt->getSource())<<"-"<< string(finalDst)
                                                          //  <<" via " <<rtable->getNextHop(finalDst,pkt->dtype,pkt->priority)<<"Pkt-Id: "<<pkt->getSequenceNumber()<<"-Type:"<<pkt->dtype<<"-priority:"<<pkt->priority; 
	//packet to be broadcasted
	if(finalDst.compare(BROADCAST_NETWORK_ADDRESS)==0)
	{
		toApplicationLayer(pkt->decapsulate());
		return;
	}
    
	//packet not destined to this node (this node isn't the next hop to the final dst)
	if((string(pkt->getDestination())).compare(SELF_NETWORK_ADDRESS)!=0)
	{
	    /*trace() << "AODV : A2 : DATA received has been discarded - from: " << string(pkt->getSource())
	                                    << " destination: " << string(pkt->getDestinationAodv())

	                                    << " receiver: " << string(pkt->getDestination());*/
	trace()<<"NOT FOR ME R "<< pkt->getDestination() <<" "<< SELF_NETWORK_ADDRESS;
		return;
	}

	//trace() << "AODV : DATA : RX : from: " << string(pkt->getSource())
				                             //   << " destination: " << string(pkt->getDestinationAodv());
  //  trace() << "AODV : DATA : sent to application - origin: " << string(pkt->getSource()) << " Pkt priority: " << pkt->priority;                                    
	PacketDATA* ndPacket = pkt->dup();

	//the final destination is this node
	if(finalDst.compare(SELF_NETWORK_ADDRESS)==0)
	{
	    collectOutput("Pkt received","DATA pkt (D)");
	    trace() << "AODV : DATA : sent to application - origin: " << string(pkt->getSource()) << " Pkt type is: " << pkt->dtype;

		toApplicationLayer(pkt->decapsulate());

		
		std::string path=getFullPath();//to check for node number. added by Raj on 5/2/2019
    	
		if(path[8]=='0') //if node is 0 added by raj on 5/2
		{
			if(simTime()>callSugar)//calls the sendSugar function every 3 seconds of simTime(). aded by Raj on 5/2
			{
				trace()<<"callSugar is... "<<callSugar;
				callSugar=callSugar+3;//For the next 3 seconds. Added by Raj on 5/2
				sendSugar();
			}
		}

		return;
	}

   
	collectOutput("Pkt received","DATA pkt (F)");
	//the packet is forwarded to the next hop (case where a route is known)
	if(rtable->isRouteValid(finalDst,pkt->dtype,pkt->priority))//changed by Raj on 23/02/19
	{
            trace() << "AODV : DATA : forwarded to destination Src-Dest-NextHop " <<string(pkt->getSource())<<"-"<< string(finalDst)<<" via " <<rtable->getNextHop(finalDst,pkt->dtype,pkt->priority)<<" hop_count:"<<rtable->getHopCount(finalDst,pkt->dtype,pkt->priority)<<":Pkt-Id: "<<pkt->getSequenceNumber();//added 2 arguments by raj on 23/02/19

            if (pkt->dtype.compare("Critical")!=0 && dropping_Flag )  //  if block is added by diana, to handle packet drops. 
            {   no_of_pkts_Dropped++;
                return;
            }    

			updateLifetimeRoute(finalDst, activeRouteTimeout,pkt->dtype,pkt->priority);//to be changed by raj on 23/02/2019
			ndPacket->setDestination((rtable->getNextHop(finalDst,pkt->dtype,pkt->priority)).c_str());//added 2 arguments by raj on 23/02
            collectOutput("Pkt sent","DATA pkt (F)");
			toMacLayer(ndPacket, resolveNetworkAddress((rtable->getNextHop(finalDst,pkt->dtype,pkt->priority)).c_str()));//added 2 arguments by raj on 23/02/19
			return;
            
	}

	//a route exist but is not valid anymore
	else if(rtable->searchByDest(finalDst,pkt->dtype,pkt->priority) && rtable->searchByDest(finalDst,pkt->dtype,pkt->priority)->flag==INVALID)//changed by raj on 23/02/19
	{
		trace() << "AODV : DATA : TX : rejected (no route anymore) - destination: " << finalDst;
	     list<string>* affectedDest = new list<string>();
	     list<string>* affectedPrecursor = new list<string>();
	     affectedDest->push_front(finalDst);
	     affectedPrecursor->push_front(ndPacket->getSource());
	     sendPktRERR(affectedDest, affectedPrecursor);
	}
	//trace() << "AODV : DATA : buffered for destination " << finalDst << " Buffer size is "<< TXBuffer.size() ;  // added by diana buffer test, this is only called by intermediate nodes 
    
         
   
    bufferPacket(ndPacket);
}

void AodvTestRouting::sendPktRREQ(int hopCount, int id, string srcIP, string dstIP, unsigned long srcSN, unsigned long dstSN, SimTime pathDelay, double path_Load)
{
    PacketRREQ* rreq = new PacketRREQ("AODV routing RREQ packet", NETWORK_LAYER_PACKET);
    rreq->setFlagD(false);
    rreq->setFlagG(false);
    rreq->setFlagJ(false);
    rreq->setFlagR(false);
    rreq->setFlagU(false);
    rreq->setHopCount(hopCount);
    rreq->setRreqID(id);
    //RREQ dst
    rreq->setDstIP(dstIP.c_str());
    rreq->setDstSN(dstSN);
    //RREQ src
    rreq->setSrcIP(srcIP.c_str());
    rreq->setSrcSN(srcSN);
    rreq->setSource(SELF_NETWORK_ADDRESS);
    rreq->setDestination(dstIP.c_str());
    SimTime pDelay = simTime();//added this line for pdelay by Raj on 19/10/18
    rreq->setpropDelay(pDelay);//added this line for pdelay by Raj on 19/10/18
    rreq->setpathDelay(pathDelay);//added by raj on 21/1.
    rreq->setpathLoad(path_Load);
    
   
    if (id == 36  || id == 39 )   
          trace()<<" @ Send_RREQ, @ 123123 , RREQ Id :"<< id<< "Path Laod "<<path_Load ; 
    
   // trace()<< " @ Send RREQ SRCIP is  "<< string(srcIP) <<"  Dst IP:" << string(dstIP) <<" Dest SN: "<< dstSN << " Src SN: "<< srcSN << " Laod is: "<<path_Load ; 

    //trace()<<"pDelay = "<<pDelay;//raj
    //trace()<<"pathDelay = "<<pathDelay;//raj
    if (getTimer(AODV_RREQ_RATE_LIMIT_TIMER).dbl() <= 0)
    {
        //rreqRetryCount[dstIP]++;
        updateRreqBroadcastedList(dstIP, srcIP, id);

        if(srcIP.compare(SELF_NETWORK_ADDRESS)==0)
        {
                updateRreqTable(dstIP,id);
                collectOutput("Pkt sent","RREQ pkt (S)");
                //two next lines used because map need a string
                trace() << "AODV : RREQ : generated for destination " << string(dstIP);
        }
        rreqRetryCount[dstIP]++;//a RREQ has been sent
        // A node SHOULD NOT originate more than RREQ_RATELIMIT RREQ messages per second
        setTimer(AODV_RREQ_RATE_LIMIT_TIMER, (double)1/rreqRatelimit);
        collectOutput("Pkt sent","RREQ pkt (F)");
        trace() << "@ Send_RREQ : forwarded to destination " << string(dstIP);
        toMacLayer(rreq, BROADCAST_MAC_ADDRESS);
    }
    else
    {
        trace() << "@ Send_RREQ: buffered for destination " << dstIP;
        rreqBuffer.push(rreq);
    }

}
// Added by diana which is ecexuted once in a RRREQ recv action
void AodvTestRouting::periodicComputation()
{
    SimTime arrivalTime1 = simTime() ;  //Returns current simulation time
    double pred_Traffic_Perc;
    double pred_Critical_Traffic_Perc;

   // if ( ( arrivalTime1 - Prev_Time_Interval) > 5  )  // Load computation is done once in a 5 secs. 5 secs must be more than RREQ sending period. Here we ave set 3secs as RREQ sending interval
   // {
       // Prev_Time_Interval_1 = arrivalTime1;

        pred_Traffic_Perc = node_Load1 / 2000 ;  // SN.node[*].Communication.Routing.netBufferSize = 2000  which is max. buffer size set @ omnetpp.ini file of RadioTest simulator 
        pred_Critical_Traffic_Perc = node_Critical_Load1 / node_Load1 ; 
         if (pred_Traffic_Perc >= 0.6 && pred_Critical_Traffic_Perc >= 0.5 && pred_Critical_Traffic_Perc <= 0.9 ) // Actual code
       // if (pred_Traffic_Perc >= 0.021 && pred_Critical_Traffic_Perc >= 0.2 && pred_Critical_Traffic_Perc <= 0.9 ) // for testing 
            drop_Ratio = pred_Traffic_Perc * pred_Critical_Traffic_Perc ;    // after dropping drop_Ratio must be set to 0. Only once it has to drop. 
        
        //drop_Ratio = 0.10;     
        no_of_Pkts_to_Drop =   drop_Ratio *   (node_Load1-node_Critical_Load1); 
        trace()<<"@ periodicComputat(), no_of_Pkts_to_Drop "<<no_of_Pkts_to_Drop;
      // trace()<<"drop_Ratio: & * : "<< drop_Ratio<<" "<< (pred_Traffic_Perc * pred_Critical_Traffic_Perc) ; 
      //  trace()<<"pred_Traffic_Perc & pred_Critical_Traffic_Perc & node_Load1 & node_Critical_Load1"<<pred_Traffic_Perc<<" "<<pred_Critical_Traffic_Perc<<" "<<node_Load1<<" "<<node_Critical_Load1;    
  //  }
}

 void AodvTestRouting::computeLoad()  
{
     //*************** Added by diana , node load computation
    
   // int temp = load_Comp_Timer *  increment_Val ; 
    int past_Load =0; 
    int past_Critical_Load =0;
    int curr_Load_Val ;
    int curr_Critical_Load_Val ;
    int temp_val1=0;
    
    SimTime arrivalTime1 = simTime() ;  //Returns current simulation time
    
  
        if ( ( arrivalTime1 - Prev_Time_Interval) > 5  )  // Load computation is done once in a 5 secs. 
       {   //trace()<<" arrivalTime1 and Prev_Time_Interval "<< arrivalTime1<< "  "<< Prev_Time_Interval;
            Prev_Time_Interval = arrivalTime1; // Interval_Start_Pkt_Count_Val is initialised to 0 in .h file
            curr_Load_Val = Recvd_Pkt_Count - Interval_Start_Pkt_Count_Val; // Recvd_Pkt_Count variable is incraesed twice, while receiving data from application layer and while receiving dat from neighbours (i.e. fromAppl() and ReceDataPkt())
            curr_Critical_Load_Val = Recvd_Critical_Pkt_Count - Interval_Start_Critical_Pkt_Count_Val;

            trace()<<" @ computeLoad Recvd_Pkt_Count() && Interval_Start_Pkt_Count_Val " << Recvd_Pkt_Count <<" && "<< Interval_Start_Pkt_Count_Val;
            Interval_Start_Pkt_Count_Val = Recvd_Pkt_Count ;     
            Interval_Start_Critical_Pkt_Count_Val =  Recvd_Critical_Pkt_Count ; 
           // increment_Val++; 
               // interval_count initialised to 0 in .h file.
            if (interval_count == Intervals_Val)  // Intervals_Val is set to 5 in .h file. Past load will store past 3 intervals load value. 
                interval_count = 0; 

            load_Array_Val[interval_count] = curr_Load_Val; // interval_count : current interval load is pointed by interval_count index 
            load_Critical_Array_Val[interval_count] = curr_Critical_Load_Val;

            for (int i=0; i<interval_count; i++)    // compute load over past intervals,  n_Intervals-1 values, except the current load value, which is pointed by interval_count index value. 
            {   past_Load = past_Load + load_Array_Val[i]; 
                past_Critical_Load = past_Critical_Load + load_Critical_Array_Val[i]; 
            }
            for (int i=interval_count+1 ; i<= Intervals_Val-1; i++)
            {   past_Load = past_Load + load_Array_Val[i]; 
                past_Critical_Load = past_Critical_Load + load_Critical_Array_Val[i]; 
            }

            interval_count++;

            for (int i=0 ; i<= Intervals_Val-1; i++)
            {   trace()<< "@computeLoad, load_Array_Val[ "<<i<<" ] is " << load_Array_Val[i] <<" interval_count is:"<< interval_count-1;  // print all these values for testing .......
                trace()<< "@computeLoad, load_CRI_Array_Val[ "<<i<<" ] is " << load_Critical_Array_Val[i] ;
                if (load_Array_Val[i] != 0) // To check non-zero past load values
                    temp_val1++;   // this variable will give no. of stored non-zero past load values 
            }                
            if (temp_val1 >1)  // to find average load value over past time. Average is computed using past load values 
            {   past_Load = past_Load /(temp_val1-1) ; // -1 since temp variableis incraesed even for cuuret load value.
                past_Critical_Load = past_Critical_Load /(temp_val1-1) ; 
            }       
            node_Load1 = (0.5*curr_Load_Val) + (0.5*past_Load) ;   // node load computed using past and current load values.   
            node_Critical_Load1 = (0.5*curr_Critical_Load_Val) + (0.5*past_Critical_Load) ;
            // trace() << " @ Rev_RREQ() dest IP " << string(pkt->getDstIP()) <<" HopCount: "<< pkt->getHopCount() ;
            
            path_Load = node_Load1; 
           

          //  trace()<<" @ computeLoad, Current load is :"<<  curr_Load_Val<< " past_Load is :"<< past_Load <<" node load "<< node_Load1 ; // << " path Load is: "<< pkt->getpathLoad() ;
           
       }    
    //*************
     // Added by diana for tetsting 
    //string val ="4" ;  // val.compare(SELF_NETWORK_ADDRESS)==0   
    //if (pkt->getRreqID() == 36 || pkt->getRreqID() == 39 )   // If node is 4 then start sending load value as 234.
    //  {   // path_Load = 123123; 
       //   trace()<<" @Recv_RREQ , Path delay @ 123123 is: "<< pkt->getpathDelay() <<" Pt Laod recv & computed is : "<<pkt->getpathLoad() <<" &  "<< path_Load<<" RREQ ID "<<pkt->getRreqID();
           // trace()<<" @Recv_RREQ , @ 123123 is: "<< " Pt Load recv & computed is : "<<pkt->getpathLoad() <<" &  "<< path_Load<<" node laod: "<< node_Load1 <<" RREQ ID "<<pkt->getRreqID();
    // }
}


void AodvTestRouting::receivePktRREQ(PacketRREQ* pkt,int srcMacAddress, double rssi, double lqi) 
{
	SimTime prevTime = pkt->getpropDelay();//added the following statements Raj 
    SimTime arrivalTime = simTime() ;//added the following statements Raj
    SimTime pDelay=arrivalTime- prevTime;//added the following statements Raj

    SimTime prevTotal = pkt->getpathDelay(); //added by raj 21/1
    SimTime pathDelay = prevTotal + pDelay;  //added by raj 21/1

    double reli = (rssi-lqi)/rssi;//added by raj on 23/2/19

     trace()<<"@ recvRREQ pkt->getpathLoad()& path_Load & pkt->getpathDelay(): "<<pkt->getpathLoad()<<" "<< path_Load <<" "<<pkt->getpathDelay();
     if ( pkt->getpathLoad() > path_Load )  // path_Load added by diana
        path_Load = pkt->getpathLoad()  ; 

     periodicComputation(); // Computes Drop ratio, added by diana    

    if(isBlacklisted(pkt->getSource()))
	{
	    trace() << "@Recv_RREQ,  discarded (blacklist) - origin: " << string(pkt->getSrcIP())
	                                                       << " id: " << pkt->getRreqID()
	                                                       << " from" << string(pkt->getSource());
	    return;
	}


	trace() << "@Recv_RREQ,  RX : origin: " << string(pkt->getSrcIP())
				                                            << " id: " << pkt->getRreqID()
				                                            << " destination: " << string(pkt->getDstIP())
				                                            << " from: " << string(pkt->getSource())
                                                            << " lqi: " << lqi
                                                            << "RSSI:" << rssi
                                                            << "Reliability: " << reli;//added on 21/01/19 //Add RSSI by raj
	//updates a route to the previous hop without a valid seq number
   // trace() << "@Recv_RREQ,  : Path Delay: "<<pathDelay << " Buffer size is: "<<TXBuffer.size()<< "Path Load: "<<path_Load;//added on 21/1/19 by raj  Diana - Added Buffer 
	updateRoute(string(pkt->getSource()), 0, false, VALID, 1, string(pkt->getSource()),NULL,0,pathDelay,reli, path_Load);//raj on 29/3/19


	//check if this node is the origin of the request
	if(string(pkt->getSrcIP()).compare(SELF_NETWORK_ADDRESS)==0)
		return;

	//check if this node has already processed or buffered this rreq, if yes drop packet
	if(checkRREQBroadcasted(pkt->getSrcIP(), pkt->getRreqID()) || checkRREQBuffered(pkt->getSrcIP(), pkt->getRreqID()))
	{
	    trace() << "@Recv_RREQ,  discarded (already broadcasted) - origin: " << string(pkt->getSrcIP())
                                                        << " id: " << pkt->getRreqID();
	    return;
	}

	//update route for the originator
	updateRoute(string(pkt->getSrcIP()), pkt->getSrcSN(), true, VALID, pkt->getHopCount() + 1, string(pkt->getSource()),NULL,0,pathDelay,reli, path_Load);//diana changed by raj on 29/03/2019

    
    if(string(pkt->getDstIP()).compare(SELF_NETWORK_ADDRESS)==0) //current node is the destination (RFC3561 chapter 6.6.1)
    {
        if(pkt->getDstSN()==currSN)
            currSN++;
     //   trace() << "@Recv_RREQ,  RX : final dst - origin: " << string(pkt->getSrcIP())
                                                            //    << " id: " << pkt->getRreqID();
        updateRreqBroadcastedList(pkt->getDstIP(), pkt->getSrcIP(), pkt->getRreqID());
        int timeout = 2*activeRouteTimeout;//MY_ROUTE_TIMOUT = 2 * ACTIVE_ROUTE_TIMEOUT

        collectOutput("Pkt sent","RREP pkt (S)");
	  //  trace() << "@Recv_RREQ, : reach destination - origin: " << string(pkt->getSrcIP())
                                                     //  << " id: " << pkt->getRreqID();
	   // trace() << "@Recv_RREQ,  RREP :"<< pDelay<<" pDelay =  "<< arrivalTime<<"(arrivalTime-prevTime)"<<prevTime <<" : sent (is the destination)";//added the pdelay here Raj
     //   trace() << "@Recv_RREQ, : Path Delay : "<<pathDelay << " Path Load is : "<< path_Load;//added on 21/1/19 by raj 

        sendPktRREP(0, string(pkt->getSrcIP()), string(SELF_NETWORK_ADDRESS), currSN, timeout, false, pkt->getRreqID());
        return;
    }

    //current node has an active route to the destination (RFC3561 chapter 6.6.2)
    if(rtable->isRouteValid(pkt->getDstIP(),"Ordinary",1))//this function is for route request hence check for any one data type. by raj
    {//We are broadcasting so this function shall not be called. raj

        Route *r = rtable->searchByDest(pkt->getDstIP(),"Ordinary",1);//never called by raj
        updateRreqBroadcastedList(pkt->getDstIP(), pkt->getSrcIP(), pkt->getRreqID());

        if(pkt->getDstSN() < r->dstSN && r->state)
        {
            trace() << "@Recv_RREQ,: success : find a valid route - origin: " << string(pkt->getSrcIP())
                                                                                    << " id: " << pkt->getRreqID();
    	  //  trace() << "@Recv_RREQ,, AODV : RREP : sent (knows the destination)";
            string srcIP = string(pkt->getSrcIP());
            string dstIP = string(pkt->getDstIP());
            int hopcount = rtable->getHopCount(dstIP,"Ordinary",1);//never called by raj
            unsigned long dstSN = rtable->getDstSN(dstIP,"Ordinary",1);//never called by raj
           /* trace() << "@Recv_RREQ,  RX : origin: " << string(pkt->getSrcIP())
                                                            << " id: " << pkt->getRreqID()
                                                            << " destination: " << string(pkt->getDstIP())
                                                            << " from: " << string(pkt->getSource()) */

            double time = getLifetimeRoute(dstIP,r->dtype,r->priority)-simTime().dbl();
            collectOutput("Pkt sent","RREP pkt (R)");
            sendPktRREP(hopcount,srcIP,dstIP,dstSN,time,false,pkt->getRreqID());
            return;
        }
    }
    //forward the rreq

    int buffSize=(int)TXBuffer.size();//added by raj on 2/2 for testing buffer size.
    trace()<<"@Recv_RREQ, checking for buffer size"<<buffSize;//added by raj on 2/2 for testing buffer size.
	int hopcount = pkt->getHopCount() + 1;
	int id = pkt->getRreqID();
	string srcIP = pkt->getSrcIP();
	string dstIP = pkt->getDstIP();
	unsigned long srcSN = pkt->getSrcSN();
	unsigned long dstSN;
	if(pkt->getDstSN() >= rtable->getDstSN(dstIP,"Ordinary",1))//All dstnSN same. Changed by raj on 23/02/2019. Unsure :(
		dstSN = pkt->getDstSN();
	else
		dstSN = rtable->getDstSN(dstIP,"Ordinary",1);//All dstnSN same. Changed by raj on 23/02/2019. Unsure :(

	sendPktRREQ(hopcount, id, srcIP, dstIP, srcSN, dstSN,pathDelay, path_Load);//added pathDelay by Raj 23/02/2019., diana 

}

void AodvTestRouting::receivePktRREP(PacketRREP* pkt,int srcMacAddress, double rssi, double lqi)
{
    trace()<< "Inside AodvTestRouting::receivePktRREP() ";
    if(string(pkt->getDestination()).compare(SELF_NETWORK_ADDRESS)!=0)
    {
        /*trace() << "AODV : A2 : RREP received has been discarded - from: " << string(pkt->getSource())
                                        << " destination: " << string(pkt->getOriginIP())
                                        << " receiver: " << string(pkt->getDestination());*/
        return;
    }
    trace() << "AODV : RREP : RX : origin (AODV dst): " << string(pkt->getDstIP())
                                                            << " destination (AODv src): " << string(pkt->getOriginIP())
                                                            << " from: " << string(pkt->getSource())
    														<< " rreqID: " << pkt->getRreqID();

    sendPktRREPack(pkt->getSource());

    //updates a route to the previous hop without a valid seq number
    updateRoute(string(pkt->getSource()), 0, false, VALID, 1, string(pkt->getSource()),NULL,0,simTime(),0, 0);
    //update route for the destination
    updateRoute(string(pkt->getDstIP()), pkt->getDstSN(),true, VALID, pkt->getHopCount() + 1, string(pkt->getSource()),NULL,pkt->getLifetime(),simTime(),0, 0);

    if(getTimer(AODV_HELLO_MESSAGE_REFRESH_TIMER).dbl()<=0)
        sendPktHELLO();
    if (!(string(pkt->getOriginIP()).compare(SELF_NETWORK_ADDRESS)==0))
    {
        //forward the rrep
        collectOutput("Pkt received","RREP pkt (F)");
        collectOutput("Pkt sent","RREP pkt (F)");
        sendPktRREP(pkt->getHopCount() + 1, string(pkt->getOriginIP()), string(pkt->getDstIP()), pkt->getDstSN(),pkt->getLifetime(),true,pkt->getRreqID());
    }
    else //the RREQ originator receives a RREP and has updated his route --> he can processed the buffered packets
    {
    	if(!rreqAnswered[pkt->getRreqID()] && shortestDelay)
    	{
    		trace()<<"shortestDelay enabled";
    		return;
    	}
    	rreqAnswered[pkt->getRreqID()]=true;
    	if(rreqTable->searchByDest(pkt->getDstIP()))
    	{
			if(rreqTable->searchByID(pkt->getRreqID()))
			{
				//calculation linked to response time
				double spendTime =simTime().dbl() - rreqSendTimes[pkt->getRreqID()];

				if(spendTime < respTimeMin)
					respTimeMin = spendTime;
				if(spendTime > respTimeMax)
					respTimeMax = spendTime;
				respTimeTotal = respTimeTotal + spendTime;
				rrepRxCount++;
				respTimeAverage = respTimeTotal/rrepRxCount;
				trace()<<"AODV : D1 : RREP received - from: "<< " RREP sender: " << string(pkt->getDstIP())<< " - time spent :"<<spendTime;
				trace()<<"AODV : D2 : number of nodes : "<< pkt->getHopCount()+1;
				//trace()<<"AODV : D2 : RREP rx time : current ="<<spendTime;
				//trace()<<"AODV : D2 : RREP rx time : maximum ="<<respTimeMax;
				//trace()<<"AODV : D2 : RREP rx time : mimimum ="<<respTimeMin;
				//trace()<<"AODV : D2 : RREP rx time : average("<<rrepRxCount<<") ="<<respTimeAverage;

				if (latencyMax > 0 && latencyBuckets > 0)
					 collectHistogram("RREQ response time, in s", spendTime);

				rreqTable->removeRREQ(pkt->getRreqID());

			}
			else
				trace() << "AODV : RREP : received but no existing id "<< pkt->getRreqID();
			collectOutput("Pkt received","RREP pkt (D)");
			rreqRetryCount[string(pkt->getDstIP())] = 0;
			processBufferedDATA(pkt->getDstIP(), false);
    	}
    	else
    		trace() << "AODV : RREP : discarded (no RREQ "<< pkt->getDstIP()<<" )";
     }

}

void AodvTestRouting::receivePktRERR(PacketRERR* pkt,int srcMacAddress, double rssi, double lqi)
{
    if(string(pkt->getDestination()).compare(SELF_NETWORK_ADDRESS)!=0)
    {
        /*trace() << "AODV : REER : RERR received has been discarded - from: " << string(pkt->getSource())
                                        << " receiver: " << string(pkt->getDestination());*/
        return;//rerr not adressed to the node
    }

    trace() << "AODV : RERR : RX : from: " << string(pkt->getSource());

    collectOutput("Pkt received","RERR pkt");
    unsigned int affDestCount = (unsigned int)pkt->getDestCount();
    if (affDestCount!=pkt->getUnreachableDstIPArraySize() || affDestCount!=pkt->getUnreachableDstSNArraySize())
        return;//broken rerr packet

    list<string>* affDest = new list<string>();
    list<string>* affPre = new list<string>();

    for (unsigned int i = 0; i < affDestCount; i++)
    {
        affDest->push_front(string(pkt->getUnreachableDstIP(i)));
        rtable->setDstSN(pkt->getUnreachableDstIP(i),pkt->getUnreachableDstSN(i));
    }

    rtable->forwardLinkFailure(pkt->getSource(),affDest,affPre);
    sendPktRERR(affDest,affPre);
}

void AodvTestRouting::receivePktHELLO(PacketHELLO* pkt)
{
    trace() << "AODV : A2 : HELLO received - origin: " << string(pkt->getSource());
    aodvTimer ht;
    hmUpdateCount[string(pkt->getSource())]++;
    ht.destination = string(pkt->getSource());
    ht.lifetime = allowedHelloLoss * helloInterval + simTime().dbl();
    helloTimer.push(ht);
    if(getTimer(AODV_HELLO_MESSAGE_EXPIRE_TIMER).dbl()<=0)
    {
        setTimer(AODV_HELLO_MESSAGE_EXPIRE_TIMER, helloTimer.top().lifetime - simTime().dbl());
    }
}



void AodvTestRouting::sendPktRREP(int hopCount, string rreqSrc, string rreqDst, unsigned long dstSN, double lifetime, bool forwarding, int idFromRREQ)
{
	// //srcIP is the originator of the rreq --> the destination for the RREP
	// //dstIP is the final destination of the rreq --> the source for the RREP
	// if(!(rtable->isRouteValid(rreqSrc)))//le noeud n'a pas de route vers la destination (srcIP)
	// {
	// 	trace()<<"AODV : RREP : TX : rejected (no route)";
	// 	return;
	// }
	// PacketRREP *rrep = new PacketRREP("AODV routing RREP packet", NETWORK_LAYER_PACKET);// commented cause no needed by raj
	// rrep->setFlagA(true);
	// rrep->setFlagR(false);
	// rrep->setPrefixSz(0);
	// rrep->setHopCount(hopCount);
	// rrep->setOriginIP(rreqSrc.c_str());
	// rrep->setDstIP(rreqDst.c_str());
	// rrep->setDstSN(dstSN);
	// rrep->setSource(SELF_NETWORK_ADDRESS);
	// rrep->setDestination((rtable->getNextHop(rreqSrc)).c_str());
	// rrep->setLifetime(lifetime);
	// rrep->setRreqID(idFromRREQ);

	// if(string(rreqDst).compare(SELF_NETWORK_ADDRESS)!=0)
	// {
	// 	rtable->addPrecursor(rreqDst, string(rtable->getNextHop(rreqSrc)));
	// }
	// if(forwarding)
	// 	updateLifetimeRoute(rreqSrc, activeRouteTimeout);
	// toMacLayer(rrep, resolveNetworkAddress((rtable->getNextHop(rreqSrc)).c_str()));

	// setRrepAckTimer((rtable->getNextHop(rreqSrc)).c_str());
}

void AodvTestRouting::sendPktHELLO()
{
    //A node SHOULD only use hello messages if it is part of an active route
    // if(rtable->isPartRouteValid())
    // {
    //     PacketHELLO* helloMsg = new PacketHELLO("AODV hello message packet", NETWORK_LAYER_PACKET);
    //     helloMsg->setSource(SELF_NETWORK_ADDRESS);
    //     helloMsg->setDestination(BROADCAST_NETWORK_ADDRESS);//commented cause not needed by raj.
    //     trace() << "AODV : B1 : HELLO msg broadcasted";
    //     collectOutput("Pkt sent","HELLO pkt");
    //     toMacLayer(helloMsg, BROADCAST_MAC_ADDRESS);
    //     setTimer(AODV_HELLO_MESSAGE_REFRESH_TIMER, helloInterval);
    // }
}

void AodvTestRouting::sendPktRERR(list<string>* affDst, list<string>* affPre)
{
	if(affDst->empty() || affPre->empty())
	{
		return;
	}
	for (list<string>::const_iterator i=affPre->begin();i!=affPre->end();++i)
	{
		const char* dest = (*i).c_str();

		int destCount = affDst->size();
		PacketRERR *rerr = new PacketRERR("AODV routing RERR packet", NETWORK_LAYER_PACKET);
		rerr->setSource(SELF_NETWORK_ADDRESS);
		rerr->setFlagN(true);
		rerr->setDestCount(destCount);
		rerr->setUnreachableDstIPArraySize(destCount);
		rerr->setUnreachableDstSNArraySize(destCount);
		rerr->setDestination(dest);
		for(int i=0;i<destCount;i++)
		{
			rerr->setUnreachableDstIP(i,affDst->front().c_str());
			rerr->setUnreachableDstSN(i,rtable->getDstSN(affDst->front().c_str(),"Ordinary",1));//changed by Raj
			affDst->pop_front();
		}
		if(getTimer(AODV_RERR_RATE_LIMIT_TIMER).dbl() <= 0)
		{
			trace() << "AODV : RERR : TX : to  " << string(dest);
			collectOutput("Pkt sent","RERR pkt");
			toMacLayer(rerr, resolveNetworkAddress(dest));
			setTimer(AODV_RREQ_RATE_LIMIT_TIMER, (double)1/rerrRatelimit);
		}
		else
		{
			trace() << "AODV : RERR : buffered for  " << string(dest);
			rerrBuffer.push(rerr);
		}
	}
}

void AodvTestRouting::sendPktRREPack(const char* neib)
{
	PacketRREPack *rrepA = new PacketRREPack("AODV routing RREP ACK packet", NETWORK_LAYER_PACKET);
	rrepA->setSource(SELF_NETWORK_ADDRESS);
	rrepA->setDestination(neib);
	collectOutput("Pkt sent","RREPack pkt");
	toMacLayer(rrepA, resolveNetworkAddress(neib));
}

void AodvTestRouting::updateLifetimeRoute(string dstIP, double time,string dtype,int priority)//changed by raj
{
    Route* r = rtable->searchByDest(dstIP,dtype,priority);//changed by raj
    if(r && rtable->getFlag(dstIP,dtype,priority)==VALID)//changed by raj

    {
        routeUpdateCount[dstIP]++;
        RouteTimer newTimer;
        newTimer.destination = string(dstIP);
        newTimer.lifetime = simTime().dbl() + time;
        newTimer.canceled = false;
        trace() << "AODV : R : extended route lifetime to " << dstIP;
        rtable->setLifetime(&newTimer,dtype,priority);//changed by raj
    }
}

double AodvTestRouting::getLifetimeRoute(const string dstIP,string dtype,int priority)//changed by raj unsure
{
	return rtable->getLifetime(dstIP,dtype,priority);//changed by raj unsure
}

void AodvTestRouting::resetLifetimeRoute(const string dstIP,string dtype,int priority)//changed by raj unsure
{
    rtable->resetTimer(dstIP,dtype,priority);//changed by raj unsure
    routeUpdateCount[dstIP]=0;
}

/**
 * \brief update the RreqRequest queue
 * \details a RREQ is really sent (not in the buffer)
 * \param dst the rreq final destination
 */

void AodvTestRouting::updateRreqTable(string dstIP, int id)
{
	//wait time should be (2^RETRY_COUNT)*NET_TRAVERSAL_TIME
	//NET_TRAVERSAL_TIME = 2*NODE_TRAVERSAL_TIME*NET_DIAMETER
    if(rreqTable->isRREQExpired(dstIP) || rreqRetryCount[dstIP]>rreqRetries)
        return;
	//double expTime = 2 * nodeTraversalTime * netDiameter;
	double lifetime = rreqExpTime * pow(double(2),double(rreqRetryCount[dstIP]));
	/*if(lifetime < simTime().dbl())
	{
        trace()<<"debug - dstIP : "<<dstIP<<" - id :"<<id;
	    return;
	}*/

	//if the first to expire changes
    RREQset* r = rreqTable->getNextExpiredRREQ();
    if(r && lifetime<r->lifetime)
           cancelTimer(AODV_RREQ_EXPIRATION_TIMER);

    rreqTable->insertRREQ(dstIP,simTime().dbl()+lifetime,id);
    rreqSendTimes[id]= simTime().dbl();
    r = rreqTable->getNextExpiredRREQ();
    double nextExpiredRREQTime = r->lifetime;

    if(getTimer(AODV_RREQ_EXPIRATION_TIMER).dbl()<=0)
    {
        setTimer(AODV_RREQ_EXPIRATION_TIMER, nextExpiredRREQTime - simTime().dbl());
    }
}

/**
 * \brief update the RreqBroadcast queue
 * \details a RREQ is really broadcasted (not in the buffer)
 * \param source  the rreq orginator
 * \param dst the rreq final destination
 * \param id the RREQ id
 */

void AodvTestRouting::updateRreqBroadcastedList(string dstIP, string srcIP, int id)
{
    if(checkRREQBroadcasted(srcIP,id))
        return;

	//double lifetime = simTime().dbl() + 2 * nodeTraversalTime * 1000; //PATH_DISCOVERY_TIME = 2 * NET_TRAVERSAL_TIME
    //double lifetime = simTime().dbl() + 2 * netTraversalTime; //PATH_DISCOVERY_TIME = 2 * NET_TRAVERSAL_TIME
    double lifetime = simTime().dbl() + rreqExpTimeB;

    //the first to expire change
	rreqBroadcastedTimer timer;
	timer.origin=srcIP;
	timer.id=id;
	timer.lifetime=lifetime;

    if(!rreqBroadTable.empty() && lifetime < rreqBroadTable.top().lifetime)
        cancelTimer(AODV_RREQ_BROADCAST_DROP_TIMER);

    rreqBroadTable.push(timer);

    if(getTimer(AODV_RREQ_BROADCAST_DROP_TIMER).dbl()<=0)
        setTimer(AODV_RREQ_BROADCAST_DROP_TIMER, rreqBroadTable.top().lifetime - simTime().dbl());
}

/**
 * \brief checks if a RREQ exist
 * \details looks if the RREQ is on going or still in the RREQ buffer
 * \param dst the rreq final destination
 */

bool AodvTestRouting::checkRREQProcessed(string dstIP)
{
	//on going
    if(rreqTable->searchByDest(dstIP))
        return true;

	//buffered
	else if(!rreqBuffer.empty())
	{
		queue<PacketRREQ*> temp = rreqBuffer;//used to avoid modification of the rreqBuffer by the process who process the buffer (processBufferedRREQ)
		PacketRREQ** q1 = &(temp.front());
		for(unsigned int i = 0; i < temp.size(); i++)
		{
			if(q1[i]!=NULL)
			{
				if(string(q1[i]->getDstIP()).compare(dstIP)==0)
				{
							return true;
				}
			}
		}
	}
	return false;
}

/**
 * \brief checks if a RREQ has already been broadcasted
 * \details looks in the broadcast queue
 * \param orig the RREQ originator
 * \param idx the RREQ id
 */
bool AodvTestRouting::checkRREQBroadcasted(string orig, int idx)
{
    const rreqBroadcastedTimer* t;
    if(!(rreqBroadTable.empty()))
    {
        t = &(rreqBroadTable.top());
        for(unsigned int i = 0; i < rreqBroadTable.size(); i++)
        {
            if(t[i].id==idx && t[i].origin.compare(orig)==0)
            {
                return true;
            }
        }
    }
    return false;
}

bool AodvTestRouting::checkRREQBuffered(string orig, int idx)
{
	queue<PacketRREQ*> temp = rreqBuffer; //used to avoid modification of the rreqBuffer by the process who process the buffer (processBufferedRREQ)
	PacketRREQ** q1 = &(temp.front());
	for(unsigned int i = 0; i < temp.size(); i++)
	{
		if(q1[i]!=NULL)
		{
			if(string(q1[i]->getSrcIP()).compare(orig)==0 && q1[i]->getRreqID()==idx)
			{
						return true;
			}
		}
	}
	return false;
}

void AodvTestRouting::updateRoute(const string dstIP,unsigned long dstSN,bool state,RoutingFlag flag,int hopCount,const string nextHopAddr, list<string>* precursor, double aTime, SimTime pathDelay, double reli, double node_Load)//raj on 29/3/19
{
    int try1=0,try2=0;
    string dtype;
    int priority;
    while(try1<8)//added the loop by raj
    {   
        if(try1<2)
        {
            if (try2==0){
                priority = 1;
            }
            else if(try2==1){
                priority = 2;
            }
            dtype="Ordinary";
        }
        else if(try1>1 && try1<4)
        {
            dtype="Reliable";
            if (try2==2){
                priority = 1;
            }
            else if(try2 == 3){
                priority = 2;
            }
        } 
        else if (try1>3 && try1<6)
        {
            dtype="Delay";
            if(try2==4){
                priority = 1;
            }
            else if(try2==5){
                priority = 2;
            }
        }
        else
        {
            dtype="Critical";
            if(try2==6){
                priority = 1;
            }
            else if(try2==7){
                priority = 2;
            }
        }

        //refer to RFC3561 chapter 6.2
	   double oldLifetime = 0;
        if(rtable->isRouteValid(dstIP,dtype,priority))//add for loop here unsure
         	double oldLifetime = getLifetimeRoute(dstIP,dtype,priority);//changed by raj

        double addTime;
        if(aTime==0)
            addTime=activeRouteTimeout;
        else
            addTime=aTime;

        double lifetime = oldLifetime<=0 ? simTime().dbl() + addTime : oldLifetime + aTime;

        RouteTimer newTimer;
        newTimer.destination = string(dstIP);
        newTimer.lifetime = lifetime;
        newTimer.canceled = false;

        const RouteTimer* r= rtable->getNextExpiredRoute();
        if(r && lifetime < r->lifetime)
            cancelTimer(AODV_ROUTING_TABLE_ENTRY_EXPIRATION_TIMER);  

        rtable->insertRoute(dstIP, dstSN, state, flag, hopCount, nextHopAddr, precursor, lifetime,pathDelay,reli,dtype,priority,node_Load );//raj on 21/2/19, load parameter is added by diana 
        rtable->setLifetime(&newTimer,dtype,priority);//changed by raj

        r = rtable->getNextExpiredRoute();
        double newTime = r->lifetime;

        if(getTimer(AODV_ROUTING_TABLE_ENTRY_EXPIRATION_TIMER).dbl()<=0)
        {
            setTimer(AODV_ROUTING_TABLE_ENTRY_EXPIRATION_TIMER, newTime - simTime().dbl());
        }
       // trace() << "AODV : R : new route created to " << dstIP<<" of dtype : "<< dtype<<" Next hop is :" << nextHopAddr << " hopcount is: "<< hopCount  ;

        try1++;
        try2++;
    }
    trace() << "AODV : R : new route created to " << dstIP<<" of dtype : "<< dtype<<" Next hop is :" << nextHopAddr << " hopcount is: "<< hopCount  ;

}

void AodvTestRouting::processBufferedDATA(string dstIP, bool drop)
{
    queue< cPacket* > bufferTemp;
    PacketDATA* currPkt;
    string val;
    trace()<<" Inside AodvTestRouting::processBufferedDATA " ; 
    
    trace()<<"@ting::processBufferedD,  TXBuffer. not empty():"<<TXBuffer.empty();  // for testing, returns routing table's each row 
    for (int j=0; val.compare("V") != 0 ;j++)
    {   val = rtable->getRouteFromTable(j);
        trace()<<"@processBufferedData, val is:"<<val; 
    }
         
    while (!TXBuffer.empty())
    {   
        currPkt = dynamic_cast <PacketDATA*>(TXBuffer.front());
        if(currPkt && string(dstIP).compare(currPkt->getDestinationAodv())==0)
        { 
           // trace()<<"@processBuffered, rtable->isRouteValid(dstIP,currPkt->dtype,currPkt->priority): "<<rtable->isRouteValid(dstIP,currPkt->dtype,currPkt->priority);
            if(!drop && rtable->isRouteValid(dstIP,currPkt->dtype,currPkt->priority))
            {
                currPkt->setDestination(rtable->getNextHop(dstIP,currPkt->dtype,currPkt->priority).c_str());//changed by raj
                trace() << "AODV : DATA : TX (out of buffer) - destination " << string(dstIP)
                        <<" via " <<rtable->getNextHop(dstIP,currPkt->dtype,currPkt->priority);//changed by raj
                if(string(currPkt->getSource()).compare(SELF_NETWORK_ADDRESS)==0)
                    collectOutput("Pkt sent","DATA pkt (BS)");
                else
                    collectOutput("Pkt sent","DATA pkt (BF)");

                toMacLayer(currPkt, resolveNetworkAddress((rtable->getNextHop(dstIP,currPkt->dtype,currPkt->priority)).c_str()));//changed 15/3/19 raj
            }
        }
        else
        {
            bufferTemp.push(TXBuffer.front());
        }

        TXBuffer.pop();
        trace()<< " @ocessBufferedata, TXBuffer.pop() is called "<<" currPkt, string(dstIP), currPkt->getDestinationAodv() currPkt->dtype, currPkt->priority "<<currPkt<<"  "<<string(dstIP)<<"  "<<currPkt->getDestinationAodv()<<":"<<currPkt->dtype<<":"<<currPkt->priority<<":" ;
        updateLifetimeRoute(string(dstIP), activeRouteTimeout,currPkt->dtype,currPkt->priority);
    }
    while (!bufferTemp.empty()) {
        TXBuffer.push(bufferTemp.front());
        trace()<< " @ocessBufferedata, TXBuffer.push() is called ";
        bufferTemp.pop();
    }
}

void AodvTestRouting::processBufferedRREQ()
{

	PacketRREQ* r=rreqBuffer.front();
	++rreqRetryCount[r->getDstIP()];

	if(!checkRREQBroadcasted(r->getSource(), r->getRreqID()))
		{
			updateRreqBroadcastedList(rreqBuffer.front()->getDstIP(),rreqBuffer.front()->getSrcIP(),rreqBuffer.front()->getRreqID());
			if(string(rreqBuffer.front()->getSrcIP()).compare(SELF_NETWORK_ADDRESS)==0)
			{
				updateRreqTable(r->getDstIP(), r->getRreqID());
				collectOutput("Pkt sent","RREQ pkt (BS)");
			}
			else
				collectOutput("Pkt sent","RREQ pkt (BF)");

			trace() << "AODV : B3 : RREQ sent (out of buffer) - destination " << string(r->getDstIP());

			toMacLayer(rreqBuffer.front(), BROADCAST_MAC_ADDRESS);
		    setTimer(AODV_RREQ_RATE_LIMIT_TIMER, (double)1/rreqRatelimit);
		}
	rreqBuffer.pop();

}

void AodvTestRouting::setRrepAckTimer(const char* neib)
{
    //check if is already waiting for the neighbor to ack
    const aodvTimer* t;
    if(!(rrepAck.empty()))
    {
        t = &(rrepAck.top());
        for(unsigned int i = 0; i < rrepAck.size(); i++)
        {
            if(t[i].destination.compare(neib)==0)
                return;
        }
    }
    rrepAcked[string(neib)]=false;
    aodvTimer timer;
    timer.destination = string(neib);
    timer.lifetime = simTime().dbl() + 2 * nodeTraversalTime;
    rrepAck.push(timer);
    if(getTimer(AODV_RREP_ACK_WAIT_TIMER).dbl()<=0){
        setTimer(AODV_RREP_ACK_WAIT_TIMER, rrepAck.top().lifetime - simTime().dbl());

    }
}

bool AodvTestRouting::isBlacklisted(const char* neib)
{
    const aodvTimer* q0;
    if(!(rreqBlacklist.empty()))
    {
        q0 = &(rreqBlacklist.top());
        for(unsigned int i = 0; i < rreqBlacklist.size(); i++)
        {
                if(q0[i].destination.compare(neib)==0)
                    return true;
        }
    }
    return false;
}

void AodvTestRouting::setBlacklistTimer(const char* neib)
{
    //check if is already in the blacklist
   if(isBlacklisted(neib))
        return;
    aodvTimer t;
    t.destination = string(neib);
    //BLACKLIST_TIMEOUT = RREQ_RETRIES * NET_TRAVERSAL_TIME
    //NET_TRAVERSAL_TIME = 2 * NODE_TREVERSAL_TIME * NET_DIAMETER
    t.lifetime = simTime().dbl() + 2 * rreqRetries * nodeTraversalTime * netDiameter;
    rreqBlacklist.push(t);
    if(getTimer(AODV_RREQ_BLACKLIST_REMOVE_TIMER).dbl()<=0){
        setTimer(AODV_RREQ_BLACKLIST_REMOVE_TIMER, rreqBlacklist.top().lifetime - simTime().dbl());

    }
}
